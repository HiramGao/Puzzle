<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>拼图</title>
  <meta name="viewport"
        content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <style>
    #canvas {
      display: block;
      margin: auto;
      width: 1110px;
    }
  </style>
</head>
<body>

<canvas id="canvas"></canvas>
</body>
<script>
  !function () {
    function Sprite(canvas, x, y, w, h, rotation) {
      if (!this instanceof Sprite) {
        return new Sprite()
      }
      this.canvas = canvas;
      this.ctx = this.canvas.getContext('2d');
      //坐标
      this.x = x;
      this.y = y;
      //大小
      this.w = w;
      this.h = h;
      //旋转角度
      this.rotation = rotation;
      this.DEG_TO_RAD/*CONST*/ = Math.PI / 180;  // 一角度多少弧度
      this._object = []; // 存放Sprite
    }

    var SpriteFn = Sprite.prototype;

    //将锚点放到中心点
    SpriteFn._beforeDraw = function () {
      var ctx = this.ctx;

      ctx.translate(this.w / 2 + this.x, this.h / 2 + this.y);
      if (this.rotation % 360 !== 0) {
        ctx.rotate(this.DEG_TO_RAD * this.rotation);
      }
      ctx.translate(-this.w / 2 - this.x, -this.h / 2 - this.y);

      this.draw();   // 画的方法
      this._drawall(); // 画出所有子Sprite


      return this;
    };

    SpriteFn.draw = function () {
      //实现这个方法
    };
    SpriteFn.run = function () {
      return this._beforeDraw();
    };
    SpriteFn._drawall = function () {
      var ctx = this.ctx;
      if (this._object.length > 0) {
        for (var i = 0, obj; obj = this._object[i]; i++) {
          ctx.save();
          obj.run();
          ctx.restore()
        }
      }
      return this;
    };
    SpriteFn.child = function (index) {
      if (index !== void 0) {
        return this._object[index]
      } else {
        return this._object;
      }
    };
    //添加子精灵
    SpriteFn.addChild = function (obj) {
      this._object.push(obj);
      return this;
    };
    //移除子精灵
    SpriteFn.removeChild = function (obj) {
      if (this.child().indexOf(obj) !== void 0) {
        this._object.splice(this.child().indexOf(obj), 1)
      }
      return this;
    };


    var canvas = document.getElementById('canvas');

    var cutRow = 2;
    /*行*/
    var cutCol = 2;
    /*列*/

    var leftAreaWidth = 900;
    var rightAreaWidth = 900;
    var areaHeight = 900;
    var areaGap = 50;

    var stage = new Sprite(canvas, 0, 0, leftAreaWidth + areaGap + rightAreaWidth, areaHeight, 0);
    stage.init = function () {
      var canvas = this.canvas;
      canvas.width = this.w;
      canvas.height = this.h;
      this.collisionPoint = [];
      return this
    };

    stage.stroke = function (startPoint, endPoint) {
      var ctx = this.ctx;
      ctx.beginPath();
      ctx.strokeStyle = "rgba(0,0,0,0.5)";
      ctx.lineWidth = 1;
      ctx.moveTo(startPoint.x, startPoint.y);
      ctx.lineTo(endPoint.x, endPoint.y);
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
      return this;
    };
    stage.draw = function () {
      //左边为拼图区域，右边为图片碎片区域

      var canvas = this.canvas;
      //画边框
      var ctx = this.ctx;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.rect(0, 0, canvas.width, canvas.height);
      ctx.stroke();
      this
        .stroke(/*划分割线*/
          {x: leftAreaWidth, y: 0}, //线开始
          {x: leftAreaWidth, y: canvas.height}//线结束
        )
        .stroke(/*划分割线*/
          {x: leftAreaWidth + areaGap, y: 0}, //线开始
          {x: leftAreaWidth + areaGap, y: canvas.height}//线结束
        );
      return this;
    };

    stage.addEvent = function () {
      var c = this.canvas;
      var self = this;
      c.addEventListener("mousemove", move, false);
      c.addEventListener("mousedown", down, false);
      c.addEventListener("mouseup", up, false);

      var isDrag = false;


      var lastPoint;

      function move(e) {
        var currentPoint;
        if (isDrag) {
          console.log(self.child().length - 1);
          var child = self.child(self.child().length - 1);
          currentPoint = getPointOnCanvas(c, e.pageX, e.pageY);
          child.x = child.x + currentPoint.x - lastPoint.x;
          child.y = child.y + currentPoint.y - lastPoint.y;
          lastPoint = currentPoint;
        }
      }


      function down(e) {
        var canvasPoint = getPointOnCanvas(c, e.pageX, e.pageY);
        var child = self.child();
        var len = child.length;

        while (len--) {
          if (child[len].isPointInSelf(canvasPoint)) {
            var tmpChild = child[len];
            self.removeChild(tmpChild);
            self.addChild(tmpChild);
            lastPoint = canvasPoint;
            self.run();
            isDrag = true;
            break;
          }
        }
      }

      function up(e) {
        if (isDrag) {
          isDrag = false;
          //判断靠近点
          checkCollisionPoint()
        }
      }

      function getPointOnCanvas(canvas, x, y) {
        var bbox = canvas.getBoundingClientRect();
        return {
          x: Math.round((x - bbox.left ) * (canvas.width / bbox.width)),
          y: Math.round((y - bbox.top) * (canvas.height / bbox.height))
        };
      }

      function checkCollisionPoint() {
        var child = self.child();
        var len = child.length;
        var currentChild;
        while (len--) {
          currentChild = child[len];
//            判断在左侧区域
          if (currentChild.x < 900) {
            var dist = self.collisionPoint.map(function (point) {
              var l1 = point.x - currentChild.x;
              var l2 = point.y - currentChild.y;
              return Math.sqrt(Math.pow(l1, 2) + Math.pow(l2, 2));
            });
            var targetPoint = self.collisionPoint[dist.indexOf(Math.min.apply(Math, dist))];
            currentChild.toTarget(targetPoint);
          }
        }
      }

      return this;
    };

    stage.setCollisionPoint = function (x, y) {
      this.collisionPoint.push({x: x, y: y})
      return this
    };

    function ImageSprite(canvas, x, y, w, h, rotation, imgInfo) {
      Sprite.call(this, canvas, x, y, w, h, rotation)
      this.img = img;
      this.imgx = imgInfo.x;
      this.imgy = imgInfo.y;
      this.imgw = imgInfo.w;
      this.imgh = imgInfo.h;
    }

    !function () {
      var Super = function () {
      };
      Super.prototype = Sprite.prototype;
      ImageSprite.prototype = new Super();
    }();
    var ImageSpriteFn = ImageSprite.prototype;

    ImageSpriteFn.draw = function () {
      with (this) {
        toTarget();
        ctx.drawImage(img, imgx, imgy, imgw, imgh, x, y, w, h);
      }
    };
    ImageSpriteFn.isPointInSelf = function (canvasPoint) {
      var x = this.x;
      var y = this.y;
      var w = this.w;
      var h = this.h;
      var r = this.rotation;
      var cx = canvasPoint.x;
      var cy = canvasPoint.y;
      switch (r) {
        case 0 :
        case 180 :
          if (cx > x && cx < x + w && cy > y && cy < y + h) {
            return true;
          }
          break;
        case 90:
        case 270:
          break;
      }
      console.log(canvasPoint);
      return false;
    };
    ImageSpriteFn.toTarget = function (targetPoint) {
      if (targetPoint) {
        this.targetPoint = targetPoint;
      }else {
        if(this.targetPoint){
          if(this.x !== this.targetPoint.x){
            if(this.x < this.targetPoint - 0.2){
              this.x = this.x + 0.2;
            }else if(this.x > this.targetPoint + 0.2){
              this.x = this.x - 0.2;
            }else {
              this.x = this.x = this.targetPoint.x;
            }

            console.log('aaaaaaaaaaaaaa');
          }
          if(this.y !== this.targetPoint.y){

          }
        }
      }
    };
    var img = new Image();
    img.onload = function () {

      stage.init();

      currentRow = 0;
      currentCol = 0;
      var cutImageWidth = img.width / cutCol;
      var cutImageHeight = img.height / cutRow;
      //画图
      for (currentRow = 0; currentRow < cutRow; currentRow++) {
        for (currentCol = 0; currentCol < cutCol; currentCol++) {
          stage
            .setCollisionPoint(cutImageWidth * currentCol + currentCol, cutImageHeight * currentRow + currentRow)
            .addChild(
              new ImageSprite(
                canvas,
                cutImageWidth * currentCol + currentCol, cutImageHeight * currentRow + currentRow, /*图片放置位置左上角*/
                cutImageWidth, cutImageHeight, /*图片放置宽高*/
                0,
                {
                  img: img,
                  x: cutImageWidth * currentCol, y: cutImageHeight * currentRow, /*图片小块左上角*/
                  w: cutImageWidth, h: cutImageHeight/*图片裁剪宽高*/
                })
            );
        }
      }

      stage
        .run()
        .addEvent();

      function animation() {
        stage
          .run();
        requestAnimationFrame(animation);
      }

      requestAnimationFrame(animation);


      window.stage = stage
    };
    img.src = './shulan.jpg';
  }();
</script>
</html>